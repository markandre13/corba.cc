// This file is generated by the corba.js IDL compiler from 'corba/interface/interface.idl'.

#include <corba/corba.hh>
#include <corba/orb.hh>
#include <corba/giop.hh>
#include <corba/coroutine.hh>
#include <cstring>
#include <vector>
#include <map>
#include <functional>
#include "interface.hh"
#include "interface_skel.hh"
#include "interface_stub.hh"

static CORBA::async<> _Peer_callString(Peer *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callString(decoder.readStringView());
    encoder.writeString(result);
}
CORBA::async<std::string> Peer_stub::callString(const std::string_view & value) {
    return get_ORB()->twowayCall<std::string>(this, "callString", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeString(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readString(); });
}
std::map<std::string_view, std::function<CORBA::async<>(Peer *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder)>> _op_Peer = {
    {"callString", _Peer_callString},
};
CORBA::async<> Peer_skel::_call(const std::string_view &operation, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto it = _op_Peer.find(operation);
    if (it == _op_Peer.end()) {
        throw CORBA::BAD_OPERATION(0, CORBA::YES);
    }
    co_await it->second(this, decoder, encoder);
};

std::string_view Peer::_rid("IDL:Peer:1.0");
std::string_view Peer::repository_id() const { return _rid;}

CORBA::async<std::shared_ptr<Peer>> Peer::_narrow(std::shared_ptr<CORBA::Object> pointer) {
    auto ptr = pointer.get();
    auto ref = dynamic_cast<CORBA::IOR *>(ptr);
    if (ref) {
        if (ref->repository_id() != "IDL:Peer:1.0") {
            co_return std::shared_ptr<Peer>();
        }
        std::shared_ptr<CORBA::ORB> orb = ref->get_ORB();
        CORBA::detail::Connection *conn = co_await orb->getConnection(ref->host, ref->port);
        auto stub = std::make_shared<Peer_stub>(orb, CORBA::blob_view(ref->objectKey), conn);
        co_return std::dynamic_pointer_cast<Peer>(stub);
    }
    auto obj = dynamic_cast<Peer*>(ptr);
    if (obj) {
        co_return std::dynamic_pointer_cast<Peer>(pointer);
    }
    co_return std::shared_ptr<Peer>();
}

static CORBA::async<> _Interface_callBoolean(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callBoolean(decoder.readBoolean());
    encoder.writeBoolean(result);
}
CORBA::async<bool> Interface_stub::callBoolean(bool value) {
    return get_ORB()->twowayCall<bool>(this, "callBoolean", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeBoolean(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readBoolean(); });
}
static CORBA::async<> _Interface_callOctet(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callOctet(decoder.readOctet());
    encoder.writeOctet(result);
}
CORBA::async<uint8_t> Interface_stub::callOctet(uint8_t value) {
    return get_ORB()->twowayCall<uint8_t>(this, "callOctet", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeOctet(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readOctet(); });
}
static CORBA::async<> _Interface_callUShort(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callUShort(decoder.readUshort());
    encoder.writeUshort(result);
}
CORBA::async<uint16_t> Interface_stub::callUShort(uint16_t value) {
    return get_ORB()->twowayCall<uint16_t>(this, "callUShort", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeUshort(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readUshort(); });
}
static CORBA::async<> _Interface_callUnsignedLong(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callUnsignedLong(decoder.readUlong());
    encoder.writeUlong(result);
}
CORBA::async<uint32_t> Interface_stub::callUnsignedLong(uint32_t value) {
    return get_ORB()->twowayCall<uint32_t>(this, "callUnsignedLong", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeUlong(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readUlong(); });
}
static CORBA::async<> _Interface_callUnsignedLongLong(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callUnsignedLongLong(decoder.readUlonglong());
    encoder.writeUlonglong(result);
}
CORBA::async<uint64_t> Interface_stub::callUnsignedLongLong(uint64_t value) {
    return get_ORB()->twowayCall<uint64_t>(this, "callUnsignedLongLong", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeUlonglong(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readUlonglong(); });
}
static CORBA::async<> _Interface_callShort(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callShort(decoder.readShort());
    encoder.writeShort(result);
}
CORBA::async<int16_t> Interface_stub::callShort(int16_t value) {
    return get_ORB()->twowayCall<int16_t>(this, "callShort", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeShort(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readShort(); });
}
static CORBA::async<> _Interface_callLong(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callLong(decoder.readLong());
    encoder.writeUlong(result);
}
CORBA::async<uint32_t> Interface_stub::callLong(int32_t value) {
    return get_ORB()->twowayCall<uint32_t>(this, "callLong", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeLong(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readUlong(); });
}
static CORBA::async<> _Interface_callLongLong(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callLongLong(decoder.readLonglong());
    encoder.writeUlonglong(result);
}
CORBA::async<uint64_t> Interface_stub::callLongLong(int64_t value) {
    return get_ORB()->twowayCall<uint64_t>(this, "callLongLong", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeLonglong(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readUlonglong(); });
}
static CORBA::async<> _Interface_callFloat(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callFloat(decoder.readFloat());
    encoder.writeFloat(result);
}
CORBA::async<float> Interface_stub::callFloat(float value) {
    return get_ORB()->twowayCall<float>(this, "callFloat", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeFloat(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readFloat(); });
}
static CORBA::async<> _Interface_callDouble(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callDouble(decoder.readDouble());
    encoder.writeDouble(result);
}
CORBA::async<double> Interface_stub::callDouble(double value) {
    return get_ORB()->twowayCall<double>(this, "callDouble", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeDouble(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readDouble(); });
}
static CORBA::async<> _Interface_callString(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callString(decoder.readStringView());
    encoder.writeString(result);
}
CORBA::async<std::string> Interface_stub::callString(const std::string_view & value) {
    return get_ORB()->twowayCall<std::string>(this, "callString", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeString(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readString(); });
}
static CORBA::async<> _Interface_callBlob(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callBlob(decoder.readBlobView());
    encoder.writeBlob(result);
}
CORBA::async<CORBA::blob> Interface_stub::callBlob(const CORBA::blob_view & value) {
    return get_ORB()->twowayCall<CORBA::blob>(this, "callBlob", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeBlob(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readBlob(); });
}
static CORBA::async<> _Interface_setPeer(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    co_await obj->setPeer(co_await Peer::_narrow(decoder.readObject(obj->get_ORB())));
}
CORBA::async<void> Interface_stub::setPeer(std::shared_ptr<Peer> peer) {
    return get_ORB()->twowayCall(this, "setPeer", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeObject(peer.get());
    });
}
static CORBA::async<> _Interface_callPeer(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->callPeer(decoder.readStringView());
    encoder.writeString(result);
}
CORBA::async<std::string> Interface_stub::callPeer(const std::string_view & value) {
    return get_ORB()->twowayCall<std::string>(this, "callPeer", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeString(value);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readString(); });
}
std::map<std::string_view, std::function<CORBA::async<>(Interface *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder)>> _op_Interface = {
    {"callBoolean", _Interface_callBoolean},
    {"callOctet", _Interface_callOctet},
    {"callUShort", _Interface_callUShort},
    {"callUnsignedLong", _Interface_callUnsignedLong},
    {"callUnsignedLongLong", _Interface_callUnsignedLongLong},
    {"callShort", _Interface_callShort},
    {"callLong", _Interface_callLong},
    {"callLongLong", _Interface_callLongLong},
    {"callFloat", _Interface_callFloat},
    {"callDouble", _Interface_callDouble},
    {"callString", _Interface_callString},
    {"callBlob", _Interface_callBlob},
    {"setPeer", _Interface_setPeer},
    {"callPeer", _Interface_callPeer},
};
CORBA::async<> Interface_skel::_call(const std::string_view &operation, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto it = _op_Interface.find(operation);
    if (it == _op_Interface.end()) {
        throw CORBA::BAD_OPERATION(0, CORBA::YES);
    }
    co_await it->second(this, decoder, encoder);
};

std::string_view Interface::_rid("IDL:Interface:1.0");
std::string_view Interface::repository_id() const { return _rid;}

CORBA::async<std::shared_ptr<Interface>> Interface::_narrow(std::shared_ptr<CORBA::Object> pointer) {
    auto ptr = pointer.get();
    auto ref = dynamic_cast<CORBA::IOR *>(ptr);
    if (ref) {
        if (ref->repository_id() != "IDL:Interface:1.0") {
            co_return std::shared_ptr<Interface>();
        }
        std::shared_ptr<CORBA::ORB> orb = ref->get_ORB();
        CORBA::detail::Connection *conn = co_await orb->getConnection(ref->host, ref->port);
        auto stub = std::make_shared<Interface_stub>(orb, CORBA::blob_view(ref->objectKey), conn);
        co_return std::dynamic_pointer_cast<Interface>(stub);
    }
    auto obj = dynamic_cast<Interface*>(ptr);
    if (obj) {
        co_return std::dynamic_pointer_cast<Interface>(pointer);
    }
    co_return std::shared_ptr<Interface>();
}

